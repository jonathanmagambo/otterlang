fn len(x: any) -> int:
    if type_of(x) == "string":
        return len(x)
    elif type_of(x) == "list":
        return len<list>(x)
    elif type_of(x) == "map":
        return len<map>(x)
    else:
        panic("len() not supported for this type")

fn cap(x: any) -> int:
    if type_of(x) == "string":
        return cap(x)
    elif type_of(x) == "list":
        return cap<list>(x)
    else:
        panic("cap() not supported for this type")

fn append(list: List, val: any) -> bool:
    if type_of(val) == "string":
        return append<list,string>(list, val) != 0
    elif type_of(val) == "int":
        return append<list,int>(list, val) != 0
    elif type_of(val) == "float":
        return append<list,float>(list, val) != 0
    elif type_of(val) == "bool":
        return append<list,bool>(list, val) != 0
    elif type_of(val) == "list":
        return append<list,list>(list, val) != 0
    elif type_of(val) == "map":
        return append<list,map>(list, val) != 0
    else:
        panic("append() not supported for this value type")

fn delete(map: Map, key: string) -> bool:
    return delete<map>(map, key) != 0

fn range(start: int, end: int) -> List:
    return range<int>(start, end)

fn range_float(start: float, end: float) -> List:
    return range<float>(start, end)

fn enumerate(list: List) -> List:
    return enumerate<list>(list)

fn list_new() -> List:
    return list.new()

fn list_get(list: List, index: int) -> string:
    return list.get(list, index)

fn map_new() -> Map:
    return map.new()

fn map_get(map: Map, key: string) -> string:
    return map.get(map, key)

fn map_set(map: Map, key: string, value: string) -> bool:
    if type_of(value) == "string":
        return map.set(map, key, value) != 0
    elif type_of(value) == "int":
        return set<map,int>(map, key, value) != 0
    elif type_of(value) == "float":
        return set<map,float>(map, key, value) != 0
    elif type_of(value) == "bool":
        return set<map,bool>(map, key, value) != 0
    elif type_of(value) == "list":
        return set<map,list>(map, key, value) != 0
    elif type_of(value) == "map":
        return set<map,map>(map, key, value) != 0
    else:
        panic("map_set() not supported for this value type")

fn map_get_int(map: Map, key: string) -> int:
    return map.get_int(map, key)

fn map_get_float(map: Map, key: string) -> float:
    return map.get_float(map, key)

fn map_get_bool(map: Map, key: string) -> bool:
    return map.get_bool(map, key)

fn map_get_list(map: Map, key: string) -> List:
    return map.get_list(map, key)

fn map_get_map(map: Map, key: string) -> Map:
    return map.get_map(map, key)

fn panic(msg: string):
    panic(msg)

fn recover() -> string:
    return recover()

fn try_func(func) -> TryHandle:
    return try(func)

fn try_result(handle: TryHandle) -> string:
    return try.result(handle)

fn try_error(handle: TryHandle) -> Error:
    return try.error(handle)

fn error_message(error: Error) -> string:
    return error.message(error)

fn defer_func(func):
    defer(func)

fn select(cases: List, default: any) -> int:
    return select(cases, default)

fn select_case(channel: int, is_send: bool, value: any) -> SelectCase:
    return select.case(channel, is_send, value)

fn type_of(x: any) -> string:
    if type_of(x) == "string":
        return type_of<string>(x)
    elif type_of(x) == "int":
        return type_of<int>(x)
    elif type_of(x) == "float":
        return type_of<float>(x)
    elif type_of(x) == "bool":
        return type_of<bool>(x)
    elif type_of(x) == "list":
        return type_of<list>(x)
    elif type_of(x) == "map":
        return type_of<map>(x)
    else:
        return type_of<opaque>(x)

fn fields(obj: any) -> string:
    return fields(obj)

fn str(x: any) -> string:
    if type_of(x) == "string":
        return stringify<string>(x)
    elif type_of(x) == "int":
        return stringify<int>(x)
    elif type_of(x) == "float":
        return stringify<float>(x)
    elif type_of(x) == "bool":
        return stringify<bool>(x)
    elif type_of(x) == "list":
        return stringify<list>(x)
    elif type_of(x) == "map":
        return stringify<map>(x)
    else:
        return "unknown"

# Deprecated alias for compatibility
fn stringify(x: any) -> string:
    return str(x)
